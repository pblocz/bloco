% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{plgdoc Documentation}
\date{September 21, 2014}
\release{1.0}
\author{pablo cabeza}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Lexer and Parser}
\label{documentation:lexer-and-parser}\label{documentation::doc}\label{documentation:documentacion-practica-plg}

\section{Structures needed}
\label{documentation:structures-needed}\begin{itemize}
\item {} 
\textbf{Type symbol table}: A table of types that should consist of:
\begin{itemize}
\item {} 
\emph{id}: the name of the type

\item {} 
\emph{size}: its width in memory (for allocating)

\item {} 
\emph{definition}: some kind of structure defining the type (fields,...)

\end{itemize}

\item {} 
\textbf{Symbol tables}: The tables of symbols each must contain:
\begin{itemize}
\item {} 
\emph{id}: the name

\item {} 
\emph{type}: the type of the variable

\item {} 
\emph{value}: some kind of pointer or other structure for the value.

\end{itemize}

It must  also be structured in  a stack manner, since  there will be
scoping to  apply to  the rules. To  accomplish this for  each scope
there will  be a table, and  when a new  scope is needed a  table is
added.
\begin{enumerate}
\item {} 
An initial table of symbols (globals).

\item {} 
When an scope is added, a table is created and linked to the
previous scope table.

\item {} 
When looking for an id, check tables in order from the
current scope up.

\item {} 
When leaving an scope remove to top table.

\end{enumerate}

\item {} 
\textbf{String table}: A table for constant strings (global table). This can be use
to optimise repeated strings.

\end{itemize}


\section{Processing}
\label{documentation:processing}
In the \DUspan{underline}{lexer} the process to decide if an identifier is a type name or variable name should be:
\begin{enumerate}
\item {} 
Lookup the \emph{type symbol table}, if the id is there, return
a type token of the type found (with a reference to the entry in the
table.)

\item {} 
Else, return new variable token.

\end{enumerate}


\section{Operators}
\label{documentation:operators}
\begin{tabulary}{\linewidth}{|L|L|L|L|}
\hline
\textsf{\relax 
Precedence
} & \textsf{\relax 
Operator
} & \textsf{\relax 
Associativtry
} & \textsf{\relax 
Description
}\\
\hline \multirow{5}{*}{
1
} & 
\DUspan{element}{()}
 &  \multirow{5}{*}{
postfix
left-right
} & 
function call
\\
 & 
\DUspan{element}{{[}{]}}
 & 
array and unnamed
tuple access
 & \\
 & 
\DUspan{element}{.}
 & 
named tuple access
 & \\
 & 
\DUspan{element}{++}
\DUspan{element}{--}
 & 
postfix ++ --
 & \\
 & 
\DUspan{element}{type{[}{]}}
 & 
array creation
 & \\
 \multirow{4}{*}{
2
} & 
\DUspan{element}{++}
\DUspan{element}{--}
 &  \multirow{4}{*}{
prefix
right-left
} & 
Prefix ++
\\
 & 
\DUspan{element}{+}
\DUspan{element}{-}
 & 
Sign op
 & \\
 & 
\DUspan{element}{\$type\$}
 & 
Casting op
 & \\
 & 
\DUspan{element}{\$}
 & 
Typeof operator
 & \\

3
 & 
\DUspan{element}{*}
\DUspan{element}{/}
\DUspan{element}{\%}
 &  \multirow{10}{*}{
infix
left-right
} & \\

4
 & 
\DUspan{element}{+}
\DUspan{element}{-}
 &  & \\

5
 & 
\DUspan{element}{\textless{}\textless{}}
\DUspan{element}{\textgreater{}\textgreater{}}
 &  & 
bitwise shift
\\

6
 & 
\DUspan{element}{\textless{}}
\DUspan{element}{\textless{}=}
\DUspan{element}{\textgreater{}}
\DUspan{element}{\textgreater{}=}
 &  & 
relational ops
\\

7
 & 
\DUspan{element}{==}
\DUspan{element}{!=}
 &  & 
relational ops
\\

8
 & 
\DUspan{element}{\&}
 &  & 
bitwise and
\\

9
 & 
\DUspan{element}{\textasciicircum{}}
 &  & 
bitwise xor
\\

10
 & 
\DUspan{element}{\textbar{}}
 &  & 
bitwise or
\\

11
 & 
\DUspan{element}{\&\&}
 &  & 
bool and
\\

12
 & 
\DUspan{element}{\textbar{}\textbar{}}
 &  & 
bool or
\\

13
 & 
\DUspan{element}{=}
\DUspan{element}{+=}
\DUspan{element}{-=}
\DUspan{element}{*=}
\DUspan{element}{/=}
\DUspan{element}{\%=}
\DUspan{element}{\textless{}\textless{}=}
\DUspan{element}{\textgreater{}\textgreater{}=}
\DUspan{element}{\&=}
\DUspan{element}{\textasciicircum{}=}
\DUspan{element}{\textbar{}=}
 & 
infix
right-left
 & 
assignment
operators
\\

14
 & 
\DUspan{element}{?:}
 &  \multirow{2}{*}{
infix (n-ary)
right-left
} & 
if operator
\\

15
 & 
\DUspan{element}{@}
 &  & 
loop operator
\\
 \multirow{2}{*}{
16
} & 
\DUspan{element}{,}
 &  \multirow{2}{*}{
infix
left-right
} & 
comma operator
\\
 & 
\DUspan{element}{`}
 & 
apostrophy
operator
 & \\
\hline\end{tabulary}



\chapter{Grammar for the language}
\label{documentation:grammar-for-the-language}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{(*}
\PYG{c}{	Will there be declarations in the language: int foo(int);}
\PYG{c}{*)}

\PYG{c}{(*}\PYG{c}{ Terminal tokens are: }\PYG{c}{*)}

\PYG{n+nv}{IDENTIFIER}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s+si}{? String from [a\PYGZhy{}zA\PYGZhy{}Z][a\PYGZhy{}zA\PYGZhy{}Z0\PYGZhy{}9\PYGZus{}]* ?}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{TYPEIDENTIFIER}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s+si}{? an IDENTIFIER in the type table ?}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{INTEGER}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s+si}{? [+\PYGZhy{}]\PYGZbs{}?[0\PYGZhy{}9]+ ?}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{FLOAT}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s+si}{? [+\PYGZhy{}]\PYGZbs{}?[0\PYGZhy{}9]*\PYGZbs{}.[0\PYGZhy{}9]+ ?}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{STRING}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s+si}{? \PYGZdq{}([\PYGZbs{}\PYGZdq{}]\textbar{}\PYGZbs{}\PYGZbs{}\PYGZdq{})*\PYGZdq{} ?}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{TYPEMODIFIERS}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}const\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}register\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}static\PYGZdq{}}
\PYG{n+nv}{BASICTYPE}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}void\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}int\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}float\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}char\PYGZdq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}bool\PYGZdq{}}\PYG{g}{ }\PYG{p}{;}



\PYG{c}{(*}\PYG{c}{ Types expression rules, an \PYGZdq{}expression\PYGZdq{} that returns a type }\PYG{c}{*)}

\PYG{n+nv}{TypeExpr}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TYPEMODIFIERS}\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{TypeExprValue}


\PYG{n+nv}{TypeExprValue}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TypeName}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Just an IDENTIFIER }\PYG{c}{*)}
\PYG{g}{	 }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{TypeExprValue}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}[\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}]\PYGZdq{}}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Array Types }\PYG{c}{*)}
\PYG{g}{	 }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{TypeExprValue}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}(\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{TypeList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{})\PYGZdq{}}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Function type }\PYG{c}{*)}
\PYG{g}{	 }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}(\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{TypeList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{})\PYGZdq{}}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Tuple without name type }\PYG{c}{*)}
\PYG{g}{	 }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}(\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{NamedTypeList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{})\PYGZdq{}}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Tuple with name }\PYG{c}{*)}
\PYG{g}{	 }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZdq{}(\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{})\PYGZdq{}}\PYG{g}{ }\PYG{c}{(*}\PYG{c}{ Empty tuple }\PYG{c}{*)}\PYG{g}{ }\PYG{p}{;}

\PYG{n+nv}{TypeList}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TypeList}\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZdq{},\PYGZdq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{NamedTypeList}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{NamedTypeList}\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZdq{},\PYGZdq{}}\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{NamedType}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{NamedType}\PYG{g}{ }\PYG{p}{;}

\PYG{n+nv}{NamedType}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}:\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{IDENTIFIER}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{TypeName}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{BASICTYPE}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{TYPEIDENTIFIER}\PYG{g}{ }\PYG{p}{;}



\PYG{c}{(*}\PYG{c}{ Definition expressions, everything that \PYGZdq{}adds\PYGZdq{}: functions, vars, ... }\PYG{c}{*)}

\PYG{n+nv}{Def}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{VarDef}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{NamedFunDef}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{AnomFunDef}\PYG{g}{ }\PYG{p}{;}

\PYG{n+nv}{VarDef}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}:\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{IDENTIFIER}\PYG{p}{,}\PYG{n+nb}{[}\PYG{n+no}{\PYGZdq{}=\PYGZdq{},Expr}\PYG{n+nb}{]}\PYG{p}{,}\PYG{n+nb}{[}\PYG{n+no}{\PYGZdq{},\PYGZdq{},IdentList}\PYG{n+nb}{]}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{IdentList}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{IDENTIFIER}\PYG{p}{,}\PYG{n+nb}{[}\PYG{n+no}{\PYGZdq{}=\PYGZdq{},Expr}\PYG{n+nb}{]}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{IDENTIFIER}\PYG{p}{,}\PYG{n+nb}{[}\PYG{n+no}{\PYGZdq{}=\PYGZdq{},Expr}\PYG{n+nb}{]}\PYG{p}{,}\PYG{l+s}{\PYGZdq{},\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{IdentList}\PYG{g}{ }\PYG{p}{;}

\PYG{n+nv}{NamedFunDef}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{p}{,}\PYG{n+nv}{IDENTIFIER}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}(\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{NamedTypeList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{})\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}\PYGZob{}\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{StmtList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}\PYGZcb{}\PYGZdq{}}\PYG{g}{ }\PYG{p}{;}
\PYG{n+nv}{AnomFunDef}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nb}{[}\PYG{n+no}{ TypeExpr }\PYG{n+nb}{[}\PYG{n+no}{ ,\PYGZdq{}(\PYGZdq{},NamedTypeList\PYGZdq{})\PYGZdq{} }\PYG{n+nb}{]}\PYG{n+no}{ }\PYG{n+nb}{]}\PYG{g}{ }\PYG{p}{,}\PYG{l+s}{\PYGZdq{}\PYGZob{}\PYGZdq{}}\PYG{p}{,}\PYG{n+nv}{StmtList}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}\PYGZcb{}\PYGZdq{}}\PYG{g}{ }\PYG{p}{;}



\PYG{c}{(*}\PYG{c}{ Expressions that return a value that can be used }\PYG{c}{*)}

\PYG{n+nv}{ValueExpr}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{p}{;}

\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}(\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{ParameterList}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{})\PYGZsq{}}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}}	  	\PYG{c}{\PYGZsh{} Block call}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{FunctionCallNode}\PYG{p}{(}\PYG{n}{\PYGZus{}1}\PYG{p}{,}\PYG{n}{\PYGZus{}3}\PYG{p}{)} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}[\PYGZsq{}}\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{ValueExpr}\PYG{g}{ }\PYG{p}{,}\PYG{l+s}{\PYGZsq{}]\PYGZsq{}}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}} 		\PYG{c}{\PYGZsh{} Array or tuple access (rvalue)}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{IndexNode}\PYG{p}{(}\PYG{n}{\PYGZus{}1}\PYG{p}{,}\PYG{n}{\PYGZus{}3}\PYG{p}{,}\PYG{n}{lvalue}\PYG{o}{=}\PYG{n}{\PYGZus{}1}\PYG{o}{.}\PYG{n}{lvalue}\PYG{p}{)} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}.\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{  }\PYG{n+nv}{IDENTIFIER}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}}			\PYG{c}{\PYGZsh{} Named tuple access (rvalue)}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{NameAccessNode}\PYG{p}{(}\PYG{n}{\PYGZus{}1}\PYG{p}{,}\PYG{n}{\PYGZus{}3}\PYG{p}{,}\PYG{n}{lvalue}\PYG{o}{=}\PYG{n}{\PYGZus{}1}\PYG{o}{.}\PYG{n}{lvalue}\PYG{p}{)} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{Expr1}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{p}{(}\PYG{l+s}{\PYGZsq{}++\PYGZsq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZsq{}}\PYG{p}{)}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}}			\PYG{c}{\PYGZsh{} postfix in/decrement *)}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{PostfixCrementNode}\PYG{p}{(}\PYG{n}{\PYGZus{}1}\PYG{p}{,}\PYG{n}{\PYGZus{}2}\PYG{p}{)} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}[\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{ValueExpr}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}]\PYGZsq{}}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}} 	 	\PYG{c}{\PYGZsh{} Array creation *)}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{ArrayCreationNode}\PYG{p}{(}\PYG{n}{\PYGZus{}1}\PYG{p}{,}\PYG{n}{\PYGZus{}3}\PYG{p}{)} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{Expr2}\PYG{g}{ }\PYG{n+nb}{\PYGZob{}}
		\PYG{n}{\PYGZus{}\PYGZus{}} \PYG{o}{=} \PYG{n}{\PYGZus{}1} \PYG{n+nb}{\PYGZcb{}}
\PYG{g}{	  }\PYG{p}{;}

\PYG{n+nv}{Expr2}\PYG{g}{ }\PYG{k}{=}\PYG{g}{ }\PYG{p}{(}\PYG{l+s}{\PYGZsq{}++\PYGZsq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZhy{}\PYGZhy{}\PYGZsq{}}\PYG{p}{)}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{Expr2}\PYG{g}{ 				}\PYG{c}{(*}\PYG{c}{ Prefix in/decrement }\PYG{c}{*)}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{p}{(}\PYG{l+s}{\PYGZsq{}+\PYGZsq{}}\PYG{g}{ }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZhy{}\PYGZsq{}}\PYG{g}{ }\PYG{p}{)}\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{Expr2}\PYG{g}{ 			}\PYG{c}{(*}\PYG{c}{ +/\PYGZhy{} sign operators }\PYG{c}{*)}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZdl{}\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{TypeExpr}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZdl{}\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{Expr2}\PYG{g}{		}\PYG{c}{(*}\PYG{c}{ type casting operator }\PYG{c}{*)}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{l+s}{\PYGZsq{}\PYGZdl{}\PYGZsq{}}\PYG{g}{ }\PYG{p}{,}\PYG{g}{ }\PYG{n+nv}{Expr2}\PYG{g}{					}\PYG{c}{(*}\PYG{c}{ typeof operator }\PYG{c}{*)}
\PYG{g}{	  }\PYG{k}{\textbar{}}\PYG{g}{ }\PYG{n+nv}{Expr3}\PYG{g}{ }\PYG{p}{;}
\end{Verbatim}

\begin{notice}{note}{Note:}
Maybe delete LValue class and have a ``flag'' in the VariableNode
to see if the variable is an RValue or LValue. If a VarNode is built
from a variable then it is an LValue, else it is an RValue
\end{notice}


\chapter{Code generation}
\label{documentation:code-generation}
We are translating bloco code into C language, that should be compiled
without problems using an standard C compiler like GCC. All type
checks are done in the identifier phase without relying in the
compiler, just using the C compiler to translate correct code into
object code (which means if a compiler error should be raised, it will
be during translation to C).

All generation related code is located in the file \emph{generate.cpp} that
implements the method \emph{generate(CodeGenerate\& g)} from each subtype of
Node.


\section{CodeGenerate}
\label{documentation:codegenerate}
This class is located in \emph{codegenerate.hpp} completely and is just an
auxiliary class that contains the already generated code separating it
in head and body sections.


\section{Auxiliary methods}
\label{documentation:auxiliary-methods}
We have a couple of auxliry methods to help computing offsets or
generating repetitive code. Those are:
\begin{itemize}
\item {} 
\textbf{namednodelistgeneratefun()}: this method generates the parameters
of a function prototype.

\item {} 
\textbf{framesize()}: computes the size of a frame, including the parent pointer.

\item {} 
\textbf{frameoffset()}: given a frame, compute the offset of a symbol
given by its index in the frame. This will be the equivalent to the
ro() function.

\item {} 
\textbf{generategetframe()}: given the full stack of frames and the pair
(i,j) representing the position of a symbol, generate an expression
that accesses this symbol.

\item {} 
\textbf{generatefun()}: generate the \emph{casting to function-pointer}
expression for the given function NodeType.

\end{itemize}


\section{First order functions}
\label{documentation:first-order-functions}
The main feature of bloco is first order functions. C doesn't have
native support for it, to implement it we have researched various
solutions given to this problem and found that the solution adopted by
the javascript language (very similar in the sense that it is
imperative plus having first order) could be implemented in C with
relative ease.

When a function is declared, for example:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nl}{int:} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{:} \PYG{n}{fun} \PYG{o}{=} \PYG{k+kt}{int} \PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{:} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{r} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{r} \PYG{n}{fun}\PYG{p}{;}
\end{Verbatim}

The differences with an standard C functions would be summarized in:
\begin{enumerate}
\item {} 
The function in generated \emph{``on the fly''}, interleaved with actual
code.

\item {} 
The function is passed to a variable of type function, that can be
then called.

\item {} 
The function has access to variables on the definition scope during
execution (closures).

\end{enumerate}

For points number 1. and 2., carefully placing the function definition
in a header and referencing it using pointers to function can solve
it.

On the other hand, point 3. is harder to implement because it implies
that variable should have a longer lifespan than just its defining
block, because they can be referenced from an inner defined function,
and that function should be able to access symbols from the upper
scope in the code.


\subsection{Frame chaining}
\label{documentation:frame-chaining}
The solution we have used to solve this problem is creating a data
structure that we call \textbf{frame}. A frame is just a chunk of memory
where we define local variables of a function, plus a pointer to the
\emph{``parent''} frame (the one in the upper scope). Then the structure of a
frame is:

\begin{Verbatim}[commandchars=\\\{\}]
0       pointer to parent frame
N       function parameters
M       local variables
\end{Verbatim}

During compilation any reference to symbols is resolved using a pair
of number (i,j) where i is the number of scopes it has to go up in the
definition chain, and j in the index of that symbol in the frame. The offset of the symbol is computed using when generating the code.

Imagine that (i,j)=(3,2), frameoffset(2)=10 and the symbol is of type \emph{int}, the generated code to reference the symbol would be:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(} \PYG{p}{(} \PYG{k+kt}{int} \PYG{o}{*}\PYG{p}{)} \PYG{p}{(}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{o}{*}\PYG{p}{)} \PYG{n}{frame}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\end{Verbatim}

\begin{notice}{note}{Note:}
The casting \emph{(((char*) frame) + M1)} is very important
because, in C \emph{pointer arithmetic}, the offset M1 is added to the
pointer \emph{frame} multiplied by the size of it's type, which means we
need to use some type of size 1 (char) for this to work properly.
\end{notice}

Using this, now each function is translated into a C function that have the form:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{\PYGZus{}\PYGZus{}anon\PYGZus{}M} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{\PYGZus{}frame}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{arg1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// M is an unique number}
\end{Verbatim}

And each function will have a prelude that consists on:
\begin{enumerate}
\item {} 
Allocating the frame using dynamic memory.

\item {} 
Assigning the parent frame to this frame.

\item {} 
Copying function parameters to the frame.

\end{enumerate}

So the prelude will look like this:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{o}{*} \PYG{n}{frame} \PYG{o}{=} \PYG{n}{malloc}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Allocate frame}
\PYG{o}{*}\PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*}\PYG{o}{*}\PYG{p}{)}\PYG{n}{frame}\PYG{o}{=}\PYG{n}{\PYGZus{}frame}\PYG{p}{;} \PYG{c+c1}{// Save parent frame}
\PYG{p}{(}\PYG{p}{(}\PYG{n}{type\PYGZus{}arg1}\PYG{o}{*}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)} \PYG{n}{frame}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arg1}\PYG{p}{;} \PYG{c+c1}{// Copy first parameter}
\PYG{p}{(}\PYG{p}{(}\PYG{n}{type\PYGZus{}arg2}\PYG{o}{*}\PYG{p}{)}\PYG{p}{(}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{*}\PYG{p}{)} \PYG{n}{frame}\PYG{p}{)} \PYG{o}{+} \PYG{n}{M2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{=} \PYG{n}{arg2}\PYG{p}{;} \PYG{c+c1}{// Copy second parameter}
\end{Verbatim}

Where \textbf{N} is the computed size of the frame and \textbf{M1},
\textbf{M2},... are the offsets of their respective function arguments in
the frame.


\subsection{Code and scope binding}
\label{documentation:code-and-scope-binding}
Now that the closure problem is solved we need to address the problem
of binding a function with its parent frame (the frame of its scope)
and calling it. We need a pair \emph{(function, frame)}, that is created
when and where a function is defined.

We first define a common C struct for anonymous functions:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{typedef} \PYG{k}{struct} \PYG{p}{\PYGZob{}} \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{code}\PYG{p}{;} \PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{frame}\PYG{p}{\PYGZcb{}} \PYG{k+kt}{anon\PYGZus{}t}\PYG{p}{;}
\end{Verbatim}

Then the translation of this bloco code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nl}{int:} \PYG{n}{c}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{o}{:} \PYG{n}{fun} \PYG{o}{=} \PYG{k+kt}{int} \PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{:} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{r} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{o}{*}\PYG{n}{c}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{Verbatim}

Would look like:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{\PYGZus{}\PYGZus{}anon\PYGZus{}1} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{\PYGZus{}frame}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{// Function prologue to create frame}
      \PYG{k}{return} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{A}\PYG{o}{*}\PYG{n}{C}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{c+c1}{// Create base frame}
      \PYG{n}{C} \PYG{o}{=} \PYG{l+m+mi}{5}\PYG{p}{;}
      \PYG{n}{FUN} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{anon\PYGZus{}t}\PYG{p}{)} \PYG{p}{\PYGZob{}}\PYG{n}{\PYGZus{}\PYGZus{}anon\PYGZus{}1}\PYG{p}{,}\PYG{n}{frame}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}

In the code \textbf{A}, \textbf{C}, \textbf{FUN} are expressions to access their
respective symbols in the frame, that are omitted to light the
example.


\subsection{Function calling}
\label{documentation:function-calling}
At this point calling the function would consist on accessing it's
\emph{.code} member, cast it to the right type and call it passing \emph{.frame}
as it's first argument and then the rest of parameters. The problem is
that it should act as an \emph{expression} because we might need it's
return value as part of another expression. This means that we need to
\emph{``give it a name''} to access each member. The solution adopted is
to generate auxiliary functions that do all this processing.

For example lets translate this code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{:} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{c} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{a}\PYG{p}{;} \PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// c is already defined}
\end{Verbatim}

This will translate into 2 functions, \emph{\_\_anon\_1} and \emph{\_\_aux\_1}, a
creation of an object of type \emph{anon\_t} and a call to \emph{\_\_aux\_1}. The result is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}anon\PYGZus{}1} \PYG{p}{(}\PYG{k+kt}{void}\PYG{o}{*} \PYG{n}{\PYGZus{}frame}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// Epilogue of function}
        \PYG{n}{C} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{A}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}aux\PYGZus{}1} \PYG{p}{(}\PYG{k+kt}{anon\PYGZus{}t} \PYG{n}{f}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{f1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{p}{)} \PYG{p}{(} \PYG{k+kt}{void}\PYG{o}{*}\PYG{p}{,} \PYG{k+kt}{int} \PYG{p}{)}\PYG{p}{)} \PYG{n}{f}\PYG{p}{.}\PYG{n}{code}\PYG{p}{)}\PYG{p}{(} \PYG{n}{f}\PYG{p}{.}\PYG{n}{frame}\PYG{p}{,} \PYG{n}{f1}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Forward parameters to actual function}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{c+c1}{// main epilogue to allocate base frame}
        \PYG{c+c1}{// ...}
        \PYG{n}{\PYGZus{}\PYGZus{}aux\PYGZus{}1} \PYG{p}{(} \PYG{p}{(}\PYG{k+kt}{anon\PYGZus{}t}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{n}{\PYGZus{}\PYGZus{}anon\PYGZus{}1} \PYG{p}{,}\PYG{n}{frame}\PYG{p}{\PYGZcb{}}\PYG{p}{,} \PYG{l+m+mi}{5} \PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{// Creation of anon\PYGZus{}t and call to \PYGZus{}\PYGZus{}aux\PYGZus{}1}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}


\chapter{Documents}
\label{documentation:documents}

\section{Links}
\label{documentation:links}\begin{itemize}
\item {} 
Pdf that explains \href{http://www.sci.tamucc.edu/~sking/Courses/Compilers/Slides/type\_checking.pdf}{type checking} .

\item {} 
\href{http://www.thebinaryidiot.com/archives/2010/03/06/}{Example} for building lex and yacc parser in c++.

\item {} 
\href{http://panthema.net/2007/flex-bison-cpp-example/}{Complete example} of c++ parser for flex and bison.

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
