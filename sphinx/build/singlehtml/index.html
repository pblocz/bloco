<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>plgdoc 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/scrolls.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/table_styling.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="None" href="index.html#document-index" />
	
	<link rel="stylesheet" href="_static/override.css" type="text/css" />
	<script type="text/javascript">
		var oldw = window.onload;
		window.onload = function(){
			if(typeof oldw === 'function'){ oldw.apply(window); }
			var table = document.getElementsByClassName('optable')[0];
			var rows = table.getElementsByTagName('tr');
			for(var r=0;r<rows.length;r++){
				var v = rows[r];
				var td = v.getElementsByClassName('first')[0];
				if(td !== undefined && td.getElementsByClassName('element').length){
					td.className= td.className.replace(/\bfirst\b/g, '');
				}
			}
		}
	</script>

	 

  </head>
  <body>
    <div id="content">
      <div class="header">
        <h1 class="heading"><a href="index.html#document-index"
          title="back to the documentation overview"><span>plgdoc 1.0 documentation</span></a></h1>
      </div>
      <div class="relnav">
        <a href="index.html#document-index">plgdoc 1.0 documentation</a>
      </div>
      <div id="contentwrapper">
        <div id="toc">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-documentation">Introducción</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#analisis-lexico">Análisis léxico</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#sintaxis">Sintaxis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#operadores">Operadores</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#gramatica-del-lenguaje">Gramática del lenguaje</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#identificadores-y-tipos">Identificadores y tipos</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#anidamiento-de-ambitos">Anidamiento de ámbitos</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#generacion-de-codigo">Generación de código</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#codegenerate">CodeGenerate</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#metodo-auxiliares">Método auxiliares</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#funciones-de-primer-orden">Funciones de primer orden</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#bibliografia">Bibliografía</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#links">Links</a></li>
</ul>
</li>
</ul>

        </div>
        
  <style type="text/css">
.underline { text-decoration: underline; }
</style><div class="section" id="documentacion-practica-plg">
<h1>Documentación práctica plg<a class="headerlink" href="#documentacion-practica-plg" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-documentation"></span><p>Autores: Pablo Cabeza García y Paco Criado Gallart</p>
<div class="section" id="introduccion">
<h2>Introducción<a class="headerlink" href="#introduccion" title="Permalink to this headline">¶</a></h2>
<p>En este documento presentamos Bloco, un lenguaje de programación y un compilador asociado, para la
asignatura de Procesadores de Lenguajes.</p>
<p>El lenguaje Bloco es fuertemente tipado y muy similar a C,
salvo que añade definiciones de funciones anidadas, como Pascal. También permite funciones
anónimas, y de primer orden, y unas reglas de visibilidad de identificadores especiales, junto con
operadores de nuestra invención y muchas otras innovaciones apuntadas a conseguir un lenguaje de
paradigma funcional/imperativo.</p>
<p>Su objetivo final es reducir los caracteres del código fuente de un programa.</p>
</div>
<div class="section" id="analisis-lexico">
<h2>Análisis léxico<a class="headerlink" href="#analisis-lexico" title="Permalink to this headline">¶</a></h2>
<p>Nuestro análisis léxico se basa una implementación del tradicional
lex, flex. La sintaxis de la gramática es muy similar, tan solo
variando algunas estructuras de control. Todo este análisis se
encuentra en <em>scanner.ll</em> y <em>scanner.hpp</em>. Cabe destacar que para los
identificadores hemos añadido una tabla de <em>&#8220;símbolo de tipo&#8221;</em>, donde
al encontrar un identificador se comprueba si es un tipo o no.</p>
</div>
<div class="section" id="sintaxis">
<h2>Sintaxis<a class="headerlink" href="#sintaxis" title="Permalink to this headline">¶</a></h2>
<p>La sintaxis del lenguaje Bloco es similar a la de c. Tenemos funciones que se pueden declarar en
cualquier ámbito, incluyendo funciones anónimas. La particularidad de nuestro lenguaje es
fundamentalmente esta.</p>
<p>Sin embargo, también hay algunas anomalías a nivel sintáctico, entre las que cabe destacar:</p>
<ol class="arabic simple">
<li>El if es sustituido por el operador &#8216;?&#8217;, que se comporta de manera parecida a la del operador
ternario de c/c++. Este recibe en vez de expresiones, funciones sin argumentos, tipicamente
funciones anónimas.</li>
<li>De la misma forma, tenemos el operador &#8216;&#64;&#8217;, que representa al bucle while (en la forma
&#8220;condición&#64;función_anonima&#8221;). Este operador utiliza funciones que reciben y devuelven void,
aunque originalmente estaba diseñado para poder anidarlo en expresiones, o como un operador
entre funciones.</li>
<li>Tambien, siguiendo la filosofía de reducir el código, nuestro lenguaje abusa del operador &#8216;,&#8217; de
c, añadiendo además el operador &#8220;apóstrofe&#8221;. Al igual que el operador coma, el apóstrofe ejecuta
una instruccion y luego la siguiente. Pero la diferencia es que el valor de la expresión es el
valor de la primera instruccion ejecutada. Así, la diferencia es la misma que la que hay entre
el ++ postfijo y prefijo de c: ++a se puede implementar como a,(a=a+1) y a++ se puede
implementar como a&#8217;(a=a+1).</li>
<li>Además, la sintaxis para expresar un tipo suele ser de la forma &#8220;tipo:variable&#8221;, al contrario
que en c/c++. Hemos optado por esta aproximación para acercarnos más a un modelo matemático de
las funciones.</li>
<li>El lenguaje Bloco soporta tipos de arrays, y tuplas anónimas y con nombre. Además, soporta
variables de tipo función, lo que permite orden superior en funciones. Pero eso se explicará más
adelante.</li>
</ol>
<div class="section" id="operadores">
<h3>Operadores<a class="headerlink" href="#operadores" title="Permalink to this headline">¶</a></h3>
<p>En las expresiones de Bloco, contamos con los siguientes operadores. Notese que es muy similar a la
tabla de operadores de c/c++.</p>
<table border="1" class="optable styled-table docutils">
<colgroup>
<col width="20%" />
<col width="22%" />
<col width="24%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="first head">Precedencia</th>
<th class="head">Operador</th>
<th class="head">Asociatividad</th>
<th class="head">Descripción</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td class="first" rowspan="6">1</td>
<td><span class="element">()</span></td>
<td rowspan="6">postfijo
izda-dcha</td>
<td>llamada a función</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">[]</span></td>
<td>acceso a array y a
tuplas anónimas</td>
</tr>
<tr class="row-even"><td class="first"><span class="element">.</span></td>
<td>acceso a tupla con
nombre</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">++</span>
<span class="element">&#8211;</span></td>
<td>++ &#8211;
postfijos</td>
</tr>
<tr class="row-even"><td class="first"><span class="element">type[]</span></td>
<td>definición de
array</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">..{..}</span></td>
<td>función anónima</td>
</tr>
<tr class="row-even"><td class="first" rowspan="6">2</td>
<td><span class="element">++</span>
<span class="element">&#8211;</span></td>
<td rowspan="6">prefijo
dcha-izda</td>
<td>++ &#8211; prefijos</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">+</span>
<span class="element">-</span></td>
<td>operadores de
signo</td>
</tr>
<tr class="row-even"><td class="first"><span class="element">~</span></td>
<td>NOT bit a bit</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">b</span></td>
<td>break</td>
</tr>
<tr class="row-even"><td class="first"><span class="element">c</span></td>
<td>continue</td>
</tr>
<tr class="row-odd"><td class="first"><span class="element">r</span></td>
<td>return</td>
</tr>
<tr class="row-even"><td class="first">3</td>
<td><span class="element">*</span>
<span class="element">/</span>
<span class="element">%</span></td>
<td rowspan="10">infijo
izda-dcha</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td class="first">4</td>
<td><span class="element">+</span>
<span class="element">-</span></td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td class="first">5</td>
<td><span class="element">&lt;&lt;</span>
<span class="element">&gt;&gt;</span></td>
<td>desplazamientos de
bits</td>
</tr>
<tr class="row-odd"><td class="first">6</td>
<td><span class="element">&lt;</span>
<span class="element">&lt;=</span>
<span class="element">&gt;</span>
<span class="element">&gt;=</span></td>
<td>operadores de
orden</td>
</tr>
<tr class="row-even"><td class="first">7</td>
<td><span class="element">==</span>
<span class="element">!=</span></td>
<td>operadores de
igualdad</td>
</tr>
<tr class="row-odd"><td class="first">8</td>
<td><span class="element">&amp;</span></td>
<td>AND bit a bit</td>
</tr>
<tr class="row-even"><td class="first">9</td>
<td><span class="element">^</span></td>
<td>XOR bit a bit</td>
</tr>
<tr class="row-odd"><td class="first">10</td>
<td><span class="element">|</span></td>
<td>OR bit a bit</td>
</tr>
<tr class="row-even"><td class="first">11</td>
<td><span class="element">&amp;&amp;</span></td>
<td>AND boolena</td>
</tr>
<tr class="row-odd"><td class="first">12</td>
<td><span class="element">||</span></td>
<td>OR booleana</td>
</tr>
<tr class="row-even"><td class="first">13</td>
<td><span class="element">:?</span></td>
<td>infijo
dcha-izda</td>
<td>operador
ternario</td>
</tr>
<tr class="row-odd"><td class="first">14</td>
<td><span class="element">=</span>
<span class="element">&#64;</span></td>
<td>infijo
dcha-izda</td>
<td>asignación
bucle &#8220;while&#8221;</td>
</tr>
<tr class="row-even"><td class="first">16</td>
<td><span class="element">,</span>
<span class="element">&#8216;</span></td>
<td>infijo
dcha-izda</td>
<td>operadores coma y
apóstrofe</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="gramatica-del-lenguaje">
<h3>Gramática del lenguaje<a class="headerlink" href="#gramatica-del-lenguaje" title="Permalink to this headline">¶</a></h3>
<p>La gramática ha sido compilada con bison, la implementación de gnu de YACC. La gramática en
cuestión que generamos es como sigue:</p>
<div class="highlight-python"><div class="highlight"><pre>0 $accept: program &quot;end of file&quot;

1 program: stmt_list

2 stmt_list: stmt_list stmt
3          | stmt

4 stmt: expr15 &#39;;&#39;
5     | declaracion &#39;;&#39;
6     | def_funcion_cte

7 expr15: expr14 &#39;,&#39; expr15
8       | expr14 &#39;\&#39;&#39; expr15
9       | expr14

10 expr14: expr14_1 &#39;=&#39; expr14
11       | expr14_2 &#39;=&#39; expr14
12       | expr14_1 &#39;@&#39; funcion_anonima
13       | expr14_2 &#39;@&#39; funcion_anonima
14       | expr14_1
15       | expr14_2

16 expr14_1: expr13 &#39;?&#39; expr14_1
17         | expr13 &#39;?&#39; expr14_2 &#39;:&#39; expr14_1
18         | expr13 &#39;?&#39; expr14_2

19 expr14_2: expr13 &#39;?&#39; expr14_2 &#39;:&#39; expr14_2
20         | expr13

21 expr13: expr13 BARRABARRA expr12
22       | expr12

23 expr12: expr12 ANDAND expr11
24       | expr11

25 expr11: expr11 &#39;|&#39; expr10
26       | expr10

27 expr10: expr10 &#39;^&#39; expr9
28       | expr9

29 expr9: expr9 &#39;&amp;&#39; expr8
30      | expr8

31 expr8: expr8 IGUALIGUAL expr7
32      | expr8 NOIGUAL expr7
33      | expr7

34 expr7: expr7 MENORIGUAL expr6
35      | expr7 MAYORIGUAL expr6
36      | expr7 &#39;&lt;&#39; expr6
37      | expr7 &#39;&gt;&#39; expr6
38      | expr6

39 expr6: expr6 MENORMENOR expr5
40      | expr6 MAYORMAYOR expr5
41      | expr5

42 expr5: expr5 &#39;+&#39; expr4
43      | expr5 &#39;-&#39; expr4
44      | expr4

45 expr4: expr4 &#39;*&#39; expr3
46      | expr4 &#39;/&#39; expr3
47      | expr4 &#39;%&#39; expr3
48      | expr3

49 expr3: MASMAS expr3
50      | MENOSMENOS expr3
51      | &#39;-&#39; expr3
52      | &#39;+&#39; expr3
53      | &#39;!&#39; expr3
54      | &#39;~&#39; expr3
55      | &#39;r&#39; expr3
56      | &#39;c&#39; expr3
57      | &#39;b&#39; expr3
58      | expr1

59 expr1: expr1 MASMAS
60      | expr1 MENOSMENOS
61      | expr1 &#39;(&#39; lista_args &#39;)&#39;
62      | expr1 &#39;[&#39; expr15 &#39;]&#39;
63      | expr1 &#39;.&#39; &quot;identifier&quot;
64      | &quot;identifier&quot;
65      | funcion_anonima
66      | type &#39;[&#39; expr15 &#39;]&#39;
67      | &quot;integer&quot;
68      | &#39;(&#39; expr15 &#39;)&#39;

69 lista_args: %empty
70           | expr14
71           | lista_args &#39;,&#39; expr14

72 funcion_anonima: &#39;{&#39; stmt_list &#39;}&#39;
73                | &#39;(&#39; lista_types_nombre &#39;)&#39; &#39;{&#39; stmt_list &#39;}&#39;
74                | type &#39;(&#39; lista_types_nombre &#39;)&#39; &#39;{&#39; stmt_list &#39;}&#39;
75                | type &#39;(&#39; &#39;)&#39; &#39;{&#39; stmt_list &#39;}&#39;

76 declaracion: type &#39;:&#39; &quot;identifier&quot;
77            | type &#39;:&#39; &quot;identifier&quot; &#39;=&#39; expr14
78            | declaracion &#39;,&#39; &quot;identifier&quot;
79            | declaracion &#39;,&#39; &quot;identifier&quot; &#39;=&#39; expr14

80 type: type &#39;[&#39; &#39;]&#39;
81     | &#39;(&#39; lista_types &#39;)&#39;
82     | &#39;(&#39; &#39;)&#39;
83     | type &#39;(&#39; lista_types &#39;)&#39;
84     | type &#39;(&#39; &#39;)&#39;
85     | &#39;(&#39; lista_types_nombre &#39;)&#39;
86     | INT

87 lista_types: type
88            | lista_types &#39;,&#39; type

89 lista_types_nombre: type &#39;:&#39; &quot;identifier&quot;
90                   | lista_types_nombre &#39;,&#39; type &#39;:&#39; &quot;identifier&quot;

91 def_funcion_cte: type &quot;identifier&quot; &#39;{&#39; stmt_list &#39;}&#39;
92                | type &quot;identifier&quot; &#39;(&#39; lista_types_nombre &#39;)&#39; &#39;{&#39; stmt_list &#39;}&#39;
93                | type &quot;identifier&quot; &#39;(&#39; &#39;)&#39; &#39;{&#39; stmt_list &#39;}&#39;
</pre></div>
</div>
<p>Una de nuestras prioridades era minimizar el número de caractéres de código que tendría un programa
Bloco. Por esto, fué bastante dificil eliminar algunas ambiguedades derivadas de la reutilización
de operadores. Por ejemplo, los paréntesis, además de expresar diferentes niveles en una expresión,
representan también el tipo tupla, y la lista de argumentos de una funcion. Además, una tupla vacía
es un tipo diferente si es anónima o no.</p>
<p>Todos estos detalles hicieron que tuviesemos que tener
mucho cuidado con algunas de las reglas de la gramática. En particular, en las reglas 72-73, podían
darse muchos tipos de ambiguedades. Notese como se han resuelto considerando la tupla vacía como un
caso aparte en la regla 82.</p>
<p>Además, bison genera el arbol de sintaxis abstracta del programa, de acuerdo a los nodos descritos
en nodes.hpp.</p>
</div>
</div>
<div class="section" id="identificadores-y-tipos">
<h2>Identificadores y tipos<a class="headerlink" href="#identificadores-y-tipos" title="Permalink to this headline">¶</a></h2>
<p>El sistema de tipos que presentamos en bloco es bastante estándar, fuertemente tipado y con tipos
funcionales:
1. Tipos básicos: int, bool (se compila como int realmente), y float (no implementado a nivel de</p>
<blockquote>
<div>tipos, pero si considerado a nivel sintáctico)</div></blockquote>
<ol class="arabic simple" start="2">
<li>Arrays, siguiendo la filosofía de Java según la cual se generan dinámicamente y comprueban los
índices en ejecución.</li>
<li>Tuplas, anónimas (se acceden como un array) y con nombre. Se corresponden con los structs de c,
y se compilan exactamente como estos.</li>
<li>Tipos funcionales. Esta es la base del lenguaje Bloco. Son valores funcionales que se pueden
asignar y modificar, como las variables, o llamar como una función normal. Se definien de dos
formas, como una función normal o como una función anónima. Un identificador de funcion normal
no se puede modificar (se comprueba en compilación), pero ambos se compilan exactamente igual.
Las funciones anónimas tienen un comportamiento especial en fase de identificadores.</li>
</ol>
<div class="section" id="anidamiento-de-ambitos">
<h3>Anidamiento de ámbitos<a class="headerlink" href="#anidamiento-de-ambitos" title="Permalink to this headline">¶</a></h3>
<p>En Bloco se considera que todo el código es una función, main, que no tiene cabecera.
Debido a que los bucles y bifurcaciones reciben funciones anónimas,  Bloco sólo genera ámbitos
en una circunstancia: cuando se define una función.</p>
<p>Los ámbitos entonces se pueden definir con una función anónima o con una función normal. En ambos
casos se sigue un procedimiento muy similar al proceso por el cual se identifican en pascal. Los
identificadores hacen referencia a cualquier variable que haya sido definida arriba en el código.
Si hay varias instancias, el identificador hace referencia al ámbito más cercano, el más anidado.</p>
<p>Cuando se resuelven los identificadores, se asocia a cada uno dos números. Uno indica cuantos
ámbitos hay que subir en el árbol de ámbitos para llegar a la definición. El otro, indica la
posición de ese identificador en el struct de variables locales de la función asociada. Estos
detalles se explicarán mejor en la parte de generacíón de código.</p>
<p>A parte de esto, el procedimiento por el que se recorre el árbol para resolver los identificadores
es el habitual: recorrer los hijos de un nodo del arbol primero, resolver sus identificadores, y su
tipo, y utilizar esta información para resolver los identificadores de los nodos superiores.</p>
<p>Para esto usamos una pila de contextos, que representa las variables que hay en el punto actual del
árbol de sintaxis abstracta. Esta pila de contextos no es el objetivo, si no el medio para lograr
resolver las referencias entre identificadores.</p>
</div>
</div>
<div class="section" id="generacion-de-codigo">
<h2>Generación de código<a class="headerlink" href="#generacion-de-codigo" title="Permalink to this headline">¶</a></h2>
<p>Estamos traduciendo código bloco a código C en el compilador, que
después será compilado sin problemas con un compilador estándar de C
como GCC. Todos las comprobaciones de tipos y otros errores se hacen
desde nuestro compilador, tan solo usando el compilador de C para la
fase de generar código máquina (esto significa que cualquier error se
detecta durante la traducción y el código C generado ya es correcto).</p>
<p>Toda la generación de código está en el archivo <em>generate.cpp</em>, donde
se implementa el método <em>generate(CodeGenerate&amp; g)</em> de cada uno de los
subtipos de nodo.</p>
<div class="section" id="codegenerate">
<h3>CodeGenerate<a class="headerlink" href="#codegenerate" title="Permalink to this headline">¶</a></h3>
<p>Esta clase se encuentra en <em>codegenerate.hpp</em> en su totalidad y es una
clase auxiliar que contiene el código ya generado, separando las
cabeceras del cuerpo.</p>
</div>
<div class="section" id="metodo-auxiliares">
<h3>Método auxiliares<a class="headerlink" href="#metodo-auxiliares" title="Permalink to this headline">¶</a></h3>
<p>Hemos usado una serie de funciones auxiliares para ayudar en el
cálculo de offsets y en la generación de código. Los métodos son:</p>
<ul class="simple">
<li><strong>namednodelistgeneratefun()</strong>: Este método genera los argumentos
del prototipo de una</li>
<li><strong>framesize()</strong>: calcula el tamaño de un frame, incluyendo el
puntero al padre.</li>
<li><strong>frameoffset()</strong>: Dado un frame, calcula el offset de un símbolo
dado por el índice en el frame. Esto sería equivalente a la función
<span class="math">\(\rho()\)</span>.</li>
<li><strong>generategetframe()</strong>: Dada la pila completa de frames y un par
(i,j) representando la posición del símbolo en la pila, genera una
expresión para acceder al símbolo.</li>
<li><strong>generatefun()</strong>: genera una expresión de <em>casting a
puntero-a-función</em> de un NodeType de función.</li>
</ul>
</div>
<div class="section" id="funciones-de-primer-orden">
<h3>Funciones de primer orden<a class="headerlink" href="#funciones-de-primer-orden" title="Permalink to this headline">¶</a></h3>
<p>La característica principal de bloco son las funciones de primer order. C no tiene esta característica, por lo que hay que implementarla de alguna forma en el lenguaje. Para ello hemos investigado algunas soluciones que se han dado a este problema y la que usa el lenguaje javascript (similar al nuestro por ser imperativo con primer order) puede ser implementada con relativa facilidad.</p>
<p>Cuando una función es declarada, por ejemplo:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">int:</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="n">fun</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">int</span><span class="o">:</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">r</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">;</span> <span class="p">};</span>
<span class="n">r</span> <span class="n">fun</span><span class="p">;</span>
</pre></div>
</div>
<p>Las diferencia con una función C normal se resumirían en:</p>
<ol class="arabic simple">
<li>La función se genera <em>&#8220;al vuelo&#8221;</em>, entrelazada con el resto de
código</li>
<li>Las funciones se comportan como variables, y por lo tanto se pueden
asignar a variables de tipo función.</li>
<li>La función tiene acceso a las variables en entorno de definición
durante la ejecución (clausuras).</li>
</ol>
<p>Los puntos .1 y .2 se pueden resolver separando el código de la
función y sus referencias usando una cabecera de definiciones para el
código y punteros a función para las referencias.</p>
<p>Por otra parte, el punto .3 es más difícil de implementar por que
implica que las variables tengan un tiempo de vida mayor que tan solo
su bloque de definición, ya que pueden ser referenciadas por funciones
internas que se ejecuten en otro ámbito.</p>
<div class="section" id="encadenamiento-de-frames">
<h4>Encadenamiento de frames<a class="headerlink" href="#encadenamiento-de-frames" title="Permalink to this headline">¶</a></h4>
<p>La solución usada para resolver este problema es crear una estructura
de datos que hemos llamado <strong>frame</strong>. Un frame es un bloque de memoria
donde se definen las variables locales de una función, además de un
puntero al frame <em>&#8220;padre&#8221;</em>. Este frame se crea en memoria dinámica
dentro de una función y nunca es borrado para que se pueda acceder
desde fuera de su ámbito. Para que esto no ocurra habría que
implementar algún tipo de recolección de basura, cosa que no estaba a
nuestro alcance. La estructura de un frame entonces es:</p>
<div class="code highlight-python"><div class="highlight"><pre>0       puntero al frame padre
N       parámetro de la función
M       variables locales
</pre></div>
</div>
<p>Durante la compilación cualquier referencia a símbolos se resuelve usando un par de números  (i,j) donde i es el número de frames que hay que ascender en la cadena de frames para encontrar el símbolo y j es el índice del símbolo en el frame. El offset en el frame se calcula durante la generación de código.</p>
<p>Supongamos que (i,j)=(3,2), frameoffset(2)=10 y el símbolo es de tipo <em>int</em>, el código generado para referenciarlo será:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="p">(</span> <span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="o">***</span><span class="p">(</span><span class="kt">char</span><span class="o">****</span><span class="p">)</span> <span class="n">frame</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">El casting <em>(((char*) frame) + M1)</em> es muy importante ya
que en <em>aritmética de punteros</em> de C, el offset M1 se suma
al puntero <em>frame</em> multiplicado por el tamaño del tipo, esto
significa que necesitamos un tipo de tamaño 1 (char) para
que funcione</p>
</div>
<p>Usando esto, cada función se traduce a una función C con la forma:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">__anon_M</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">_frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg1</span><span class="p">);</span> <span class="c1">// M is an unique number</span>
</pre></div>
</div>
<p>Además cada función tendrá un epílogo que consiste en:</p>
<ol class="arabic simple">
<li>Crear el frame en memoria dinámica.</li>
<li>Asignar el punter padre a este frame</li>
<li>Copiar los parámetro de la función al frame</li>
</ol>
<p>Así el epílogo se parecerá a:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">N</span><span class="p">);</span> <span class="c1">// Allocate frame</span>
<span class="o">*</span><span class="p">(</span><span class="kt">void</span><span class="o">**</span><span class="p">)</span><span class="n">frame</span><span class="o">=</span><span class="n">_frame</span><span class="p">;</span> <span class="c1">// Save parent frame</span>
<span class="p">((</span><span class="n">type_arg1</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">M1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg1</span><span class="p">;</span> <span class="c1">// Copy first parameter</span>
<span class="p">((</span><span class="n">type_arg2</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">M2</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg2</span><span class="p">;</span> <span class="c1">// Copy second parameter</span>
</pre></div>
</div>
<p>Done <strong>N</strong> el tamaño calculado del frame y <strong>M1</strong>, <strong>M2</strong>,... los
offsets de sus respectivos argumentos en el frame.</p>
</div>
<div class="section" id="union-del-codigo-y-el-entorno">
<h4>Unión del código y el entorno<a class="headerlink" href="#union-del-codigo-y-el-entorno" title="Permalink to this headline">¶</a></h4>
<p>Ahora que el problema de las clausuras está solucionado hay que ver
cómo se hace la unión entre el código que se ejecuta y el entorno (el
frame padre) y como se ejecuta. Para ello necesitamos un par
<em>(función, frame)</em>, que se crea en el cuerpo cuando y donde la función
anónima es definida.</p>
<p>Para ello definimos un tipo común para todas las funciones anónimas:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">void</span><span class="o">*</span> <span class="n">code</span><span class="p">;</span> <span class="kt">void</span><span class="o">*</span> <span class="n">frame</span><span class="p">}</span> <span class="kt">anon_t</span><span class="p">;</span>
</pre></div>
</div>
<p>Entonces, por ejemplo, la traducción de este bloque de código:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">int:</span> <span class="n">c</span><span class="o">=</span><span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">:</span> <span class="n">fun</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">int</span><span class="o">:</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">r</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>Se parecerá a:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">__anon_1</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">_frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Function prologue to create frame</span>
      <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// Create base frame</span>
      <span class="n">C</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
      <span class="n">FUN</span> <span class="o">=</span> <span class="p">(</span><span class="kt">anon_t</span><span class="p">)</span> <span class="p">{</span><span class="n">__anon_1</span><span class="p">,</span><span class="n">frame</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Donde <strong>A</strong>, <strong>C</strong>, <strong>FUN</strong> son expresiones para acceder a los
símbolos del frame.</p>
</div>
<div class="section" id="llamada-a-funciones">
<h4>Llamada a funciones<a class="headerlink" href="#llamada-a-funciones" title="Permalink to this headline">¶</a></h4>
<p>En este punto llamar a la función consistiría en acceder al miembro
<em>.code</em>, hacer el casting al tipo <em>punter-a-función</em> correcto y
llamarlo usando <em>.frame</em> y el resto de parámetros.</p>
<p>El problema es que el resultado tiene que ser una expresión para poder
usar su valor de retorno como parte de otras expresiones, con lo que necesitamos hacer el anterior proceso en un sólo paso. La solución que hemos adoptado es genearar funciones auxiliares que realicen esto.</p>
<p>Por ejemplo, la traducción del código:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">((</span><span class="kt">int</span><span class="o">:</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">;</span> <span class="p">})(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// c is already defined</span>
</pre></div>
</div>
<p>Serían 2 funciones, <em>__anon_1</em> and <em>__aux_1</em>, la creación de un objeto
de tipo <em>anon_t</em> y la llamada a <em>__aux_1</em>. El resultado es:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">__anon_1</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">_frame</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Prologue of function</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">__aux_1</span> <span class="p">(</span><span class="kt">anon_t</span> <span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">))</span> <span class="n">f</span><span class="p">.</span><span class="n">code</span><span class="p">)(</span> <span class="n">f</span><span class="p">.</span><span class="n">frame</span><span class="p">,</span> <span class="n">f1</span><span class="p">);</span> <span class="c1">// Forward parameters to actual function</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// main prologue to allocate base frame</span>
        <span class="c1">// ...</span>
        <span class="n">__aux_1</span> <span class="p">(</span> <span class="p">(</span><span class="kt">anon_t</span><span class="p">)</span> <span class="p">{</span> <span class="n">__anon_1</span> <span class="p">,</span><span class="n">frame</span><span class="p">},</span> <span class="mi">5</span> <span class="p">);</span> <span class="c1">// Creation of anon_t and call to __aux_1</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="bibliografia">
<h2>Bibliografía<a class="headerlink" href="#bibliografia" title="Permalink to this headline">¶</a></h2>
<div class="section" id="links">
<h3>Links<a class="headerlink" href="#links" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Apuntes de la asignatura de PLG, curso 2013-2014</li>
<li>Pdf sobre la  <a class="reference external" href="http://www.sci.tamucc.edu/~sking/Courses/Compilers/Slides/type_checking.pdf">comprobación de tipos</a> .</li>
<li><a class="reference external" href="http://www.thebinaryidiot.com/archives/2010/03/06/">Ejemplo</a> de un compilador en yacc y c++</li>
<li><a href="#id1"><span class="problematic" id="id2">`</span></a>Otro ejemplo  &lt;<a class="reference external" href="http://panthema.net/2007/flex-bison-cpp-example/">http://panthema.net/2007/flex-bison-cpp-example/</a>&gt;`_u</li>
</ul>
</div>
</div>
</div>
</div>


      </div>
    </div>

    <div class="footer">
        &copy; Copyright 2014, Pablo Cabeza &amp; Paco Criado.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>